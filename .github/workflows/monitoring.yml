name: System Monitoring

on:
  schedule:
    # Check every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch: # Allow manual trigger

env:
  PYTHON_VERSION: "3.11"

jobs:
  health-check:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install dependencies
      run: |
        pip install requests httpx pandas

    - name: Test API Health
      env:
        API_URL: ${{ secrets.RAILWAY_API_URL }}
      run: |
        python -c "
        import requests
        import json
        import sys
        import os
        from datetime import datetime
        
        api_url = os.getenv('API_URL')
        
        if not api_url:
            print('‚ö†Ô∏è  No Railway API URL configured yet')
            print('üìã To enable monitoring:')
            print('   1. Deploy to Railway first')
            print('   2. Add RAILWAY_API_URL secret in GitHub')
            print('   3. Re-run this workflow')
            sys.exit(0)
        
        def test_endpoint(endpoint, expected_status=200):
            try:
                response = requests.get(f'{api_url}{endpoint}', timeout=30)
                print(f'‚úÖ {endpoint}: {response.status_code} - {response.reason}')
                return response.status_code == expected_status
            except Exception as e:
                print(f'‚ùå {endpoint}: Error - {str(e)}')
                return False
        
        print(f'üîç Testing API at {api_url}')
        print(f'üìÖ Timestamp: {datetime.now()}')
        print()
        
        # Test endpoints
        endpoints = {
            '/': 200,
            '/health': 200,
            '/events?limit=1': 200,
            '/stats': 200
        }
        
        results = []
        for endpoint, expected in endpoints.items():
            success = test_endpoint(endpoint, expected)
            results.append(success)
        
        # Overall health
        if all(results):
            print('\\nüü¢ All systems operational')
            sys.exit(0)
        else:
            print('\\nüî¥ System degraded')
            sys.exit(1)
        "

    - name: Check Database Health
      env:
        API_URL: ${{ secrets.RAILWAY_API_URL }}
      run: |
        python -c "
        import requests
        import json
        import os
        from datetime import datetime
        
        api_url = os.getenv('API_URL')
        if not api_url:
            print('‚ö†Ô∏è  Skipping database health check - no Railway URL configured')
            exit(0)
        
        try:
            response = requests.get(f'{api_url}/health', timeout=30)
            health_data = response.json()
            
            print('üìä Database Health:')
            print(f'   Status: {health_data.get(\"database_status\", \"unknown\")}')
            print(f'   Total Events: {health_data.get(\"events_count\", 0)}')
            print(f'   Upcoming Events: {health_data.get(\"upcoming_events\", 0)}')
            
            # Alert if low event count
            upcoming = health_data.get('upcoming_events', 0)
            if upcoming < 10:
                print('‚ö†Ô∏è  Warning: Low upcoming event count!')
                
        except Exception as e:
            print(f'‚ùå Database health check failed: {e}')
        "

    - name: Test Performance
      env:
        API_URL: ${{ secrets.RAILWAY_API_URL || 'https://your-app.railway.app' }}
      run: |
        python -c "
        import requests
        import time
        from statistics import mean
        
        api_url = '${{ env.API_URL }}'
        
        def measure_response_time(endpoint):
            times = []
            for i in range(3):
                start = time.time()
                try:
                    response = requests.get(f'{api_url}{endpoint}', timeout=30)
                    end = time.time()
                    if response.status_code == 200:
                        times.append((end - start) * 1000)  # Convert to ms
                except:
                    pass
                time.sleep(1)
            return mean(times) if times else None
        
        print('‚ö° Performance Check:')
        
        endpoints = ['/health', '/events?limit=10', '/stats']
        for endpoint in endpoints:
            avg_time = measure_response_time(endpoint)
            if avg_time:
                status = 'üü¢' if avg_time < 1000 else 'üü°' if avg_time < 3000 else 'üî¥'
                print(f'   {endpoint}: {avg_time:.0f}ms {status}')
            else:
                print(f'   {endpoint}: Failed ‚ùå')
        "

  create-issue-on-failure:
    needs: health-check
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Log Failure
      run: |
        echo "üö® System Health Check Failed - $(date)"
        echo "This would create an issue, but requires additional GitHub permissions"
        echo "Manual action required: Check Railway deployment status"

  weekly-report:
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 6 * * 1'  # Monday 6 AM
    
    steps:
    - name: Generate Weekly Report
      env:
        API_URL: ${{ secrets.RAILWAY_API_URL || 'https://your-app.railway.app' }}
      run: |
        python -c "
        import requests
        from datetime import datetime, timedelta
        
        api_url = '${{ env.API_URL }}'
        
        try:
            # Get current stats
            response = requests.get(f'{api_url}/stats', timeout=30)
            stats = response.json()
            
            health_response = requests.get(f'{api_url}/health', timeout=30)
            health = health_response.json()
            
            print('# Weekly System Report')
            print(f'**Generated**: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S UTC\")}')
            print()
            print('## System Status')
            print(f'- API Status: {health.get(\"status\", \"unknown\")}')
            print(f'- Database Status: {health.get(\"database_status\", \"unknown\")}')
            print()
            print('## Event Statistics')
            print(f'- Total Events: {stats.get(\"total_events\", \"N/A\")}')
            print(f'- Upcoming Events: {stats.get(\"upcoming_events\", \"N/A\")}')
            print()
            print('## Top Venues')
            venues = stats.get(\"by_venue\", [])[:5]
            for venue in venues:
                print(f'- {venue.get(\"name\", \"Unknown\")}: {venue.get(\"count\", 0)} events')
            
        except Exception as e:
            print(f'Failed to generate weekly report: {e}')
        " > weekly_report.md
        
        cat weekly_report.md

    - name: Display Weekly Report
      run: |
        echo "üìä Weekly System Report - $(date)"
        echo "Report would be posted as GitHub issue (requires additional permissions)"
        echo "For now, check the workflow logs for the report details"